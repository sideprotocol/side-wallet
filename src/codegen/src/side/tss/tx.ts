//@ts-nocheck
import { Duration, DurationAmino, DurationSDKType } from "../../google/protobuf/duration";
import { Params, ParamsAmino, ParamsSDKType } from "./params";
import { BinaryReader, BinaryWriter } from "../../binary";
/** MsgCompleteDKG is the Msg/CompleteDKG request type. */
export interface MsgCompleteDKG {
  /** sender */
  sender: string;
  /** DKG request id */
  id: bigint;
  /** public keys generated by DKG */
  pubKeys: string[];
  /** participant consensus pub key */
  consensusPubkey: string;
  /** hex encoded participant signature */
  signature: string;
}
export interface MsgCompleteDKGProtoMsg {
  typeUrl: "/side.tss.MsgCompleteDKG";
  value: Uint8Array;
}
/** MsgCompleteDKG is the Msg/CompleteDKG request type. */
export interface MsgCompleteDKGAmino {
  /** sender */
  sender?: string;
  /** DKG request id */
  id?: string;
  /** public keys generated by DKG */
  pub_keys?: string[];
  /** participant consensus pub key */
  consensus_pubkey?: string;
  /** hex encoded participant signature */
  signature?: string;
}
export interface MsgCompleteDKGAminoMsg {
  type: "/side.tss.MsgCompleteDKG";
  value: MsgCompleteDKGAmino;
}
/** MsgCompleteDKG is the Msg/CompleteDKG request type. */
export interface MsgCompleteDKGSDKType {
  sender: string;
  id: bigint;
  pub_keys: string[];
  consensus_pubkey: string;
  signature: string;
}
/** MsgCompleteDKGResponse defines the Msg/CompleteDKG response type. */
export interface MsgCompleteDKGResponse {}
export interface MsgCompleteDKGResponseProtoMsg {
  typeUrl: "/side.tss.MsgCompleteDKGResponse";
  value: Uint8Array;
}
/** MsgCompleteDKGResponse defines the Msg/CompleteDKG response type. */
export interface MsgCompleteDKGResponseAmino {}
export interface MsgCompleteDKGResponseAminoMsg {
  type: "/side.tss.MsgCompleteDKGResponse";
  value: MsgCompleteDKGResponseAmino;
}
/** MsgCompleteDKGResponse defines the Msg/CompleteDKG response type. */
export interface MsgCompleteDKGResponseSDKType {}
/** MsgSubmitSignatures defines the Msg/SubmitSignatures request type. */
export interface MsgSubmitSignatures {
  sender: string;
  id: bigint;
  signatures: string[];
}
export interface MsgSubmitSignaturesProtoMsg {
  typeUrl: "/side.tss.MsgSubmitSignatures";
  value: Uint8Array;
}
/** MsgSubmitSignatures defines the Msg/SubmitSignatures request type. */
export interface MsgSubmitSignaturesAmino {
  sender?: string;
  id?: string;
  signatures?: string[];
}
export interface MsgSubmitSignaturesAminoMsg {
  type: "/side.tss.MsgSubmitSignatures";
  value: MsgSubmitSignaturesAmino;
}
/** MsgSubmitSignatures defines the Msg/SubmitSignatures request type. */
export interface MsgSubmitSignaturesSDKType {
  sender: string;
  id: bigint;
  signatures: string[];
}
/** MsgSubmitSignaturesResponse defines the Msg/SubmitSignatures response type. */
export interface MsgSubmitSignaturesResponse {}
export interface MsgSubmitSignaturesResponseProtoMsg {
  typeUrl: "/side.tss.MsgSubmitSignaturesResponse";
  value: Uint8Array;
}
/** MsgSubmitSignaturesResponse defines the Msg/SubmitSignatures response type. */
export interface MsgSubmitSignaturesResponseAmino {}
export interface MsgSubmitSignaturesResponseAminoMsg {
  type: "/side.tss.MsgSubmitSignaturesResponse";
  value: MsgSubmitSignaturesResponseAmino;
}
/** MsgSubmitSignaturesResponse defines the Msg/SubmitSignatures response type. */
export interface MsgSubmitSignaturesResponseSDKType {}
/** MsgRefresh defines the Msg/Refresh request type. */
export interface MsgRefresh {
  /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
  authority: string;
  /** list of DKGs corresponding to key shares to be refreshed */
  dkgIds: bigint[];
  /** removed participant set */
  removedParticipants: string[];
  /** new threshold set corresponding to the DKGs */
  thresholds: number[];
  /** timeout duration per DKG refreshing */
  timeoutDuration: Duration;
}
export interface MsgRefreshProtoMsg {
  typeUrl: "/side.tss.MsgRefresh";
  value: Uint8Array;
}
/** MsgRefresh defines the Msg/Refresh request type. */
export interface MsgRefreshAmino {
  /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
  authority?: string;
  /** list of DKGs corresponding to key shares to be refreshed */
  dkg_ids?: string[];
  /** removed participant set */
  removed_participants?: string[];
  /** new threshold set corresponding to the DKGs */
  thresholds?: number[];
  /** timeout duration per DKG refreshing */
  timeout_duration?: DurationAmino;
}
export interface MsgRefreshAminoMsg {
  type: "/side.tss.MsgRefresh";
  value: MsgRefreshAmino;
}
/** MsgRefresh defines the Msg/Refresh request type. */
export interface MsgRefreshSDKType {
  authority: string;
  dkg_ids: bigint[];
  removed_participants: string[];
  thresholds: number[];
  timeout_duration: DurationSDKType;
}
/** MsgRefreshResponse defines the Msg/Refresh response type. */
export interface MsgRefreshResponse {}
export interface MsgRefreshResponseProtoMsg {
  typeUrl: "/side.tss.MsgRefreshResponse";
  value: Uint8Array;
}
/** MsgRefreshResponse defines the Msg/Refresh response type. */
export interface MsgRefreshResponseAmino {}
export interface MsgRefreshResponseAminoMsg {
  type: "/side.tss.MsgRefreshResponse";
  value: MsgRefreshResponseAmino;
}
/** MsgRefreshResponse defines the Msg/Refresh response type. */
export interface MsgRefreshResponseSDKType {}
/** MsgCompleteRefreshing defines the Msg/CompleteRefreshing request type. */
export interface MsgCompleteRefreshing {
  /** sender */
  sender: string;
  /** request id */
  id: bigint;
  /** participant consensus pub key */
  consensusPubkey: string;
  /** hex encoded participant signature */
  signature: string;
}
export interface MsgCompleteRefreshingProtoMsg {
  typeUrl: "/side.tss.MsgCompleteRefreshing";
  value: Uint8Array;
}
/** MsgCompleteRefreshing defines the Msg/CompleteRefreshing request type. */
export interface MsgCompleteRefreshingAmino {
  /** sender */
  sender?: string;
  /** request id */
  id?: string;
  /** participant consensus pub key */
  consensus_pubkey?: string;
  /** hex encoded participant signature */
  signature?: string;
}
export interface MsgCompleteRefreshingAminoMsg {
  type: "/side.tss.MsgCompleteRefreshing";
  value: MsgCompleteRefreshingAmino;
}
/** MsgCompleteRefreshing defines the Msg/CompleteRefreshing request type. */
export interface MsgCompleteRefreshingSDKType {
  sender: string;
  id: bigint;
  consensus_pubkey: string;
  signature: string;
}
/** MsgCompleteRefreshingResponse defines the Msg/CompleteRefreshing response type. */
export interface MsgCompleteRefreshingResponse {}
export interface MsgCompleteRefreshingResponseProtoMsg {
  typeUrl: "/side.tss.MsgCompleteRefreshingResponse";
  value: Uint8Array;
}
/** MsgCompleteRefreshingResponse defines the Msg/CompleteRefreshing response type. */
export interface MsgCompleteRefreshingResponseAmino {}
export interface MsgCompleteRefreshingResponseAminoMsg {
  type: "/side.tss.MsgCompleteRefreshingResponse";
  value: MsgCompleteRefreshingResponseAmino;
}
/** MsgCompleteRefreshingResponse defines the Msg/CompleteRefreshing response type. */
export interface MsgCompleteRefreshingResponseSDKType {}
/**
 * MsgUpdateParams is the Msg/UpdateParams request type.
 * 
 * Since: cosmos-sdk 0.47
 */
export interface MsgUpdateParams {
  /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
  authority: string;
  /**
   * params defines the x/tss parameters to be updated.
   * 
   * NOTE: All parameters must be supplied.
   */
  params: Params;
}
export interface MsgUpdateParamsProtoMsg {
  typeUrl: "/side.tss.MsgUpdateParams";
  value: Uint8Array;
}
/**
 * MsgUpdateParams is the Msg/UpdateParams request type.
 * 
 * Since: cosmos-sdk 0.47
 */
export interface MsgUpdateParamsAmino {
  /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
  authority?: string;
  /**
   * params defines the x/tss parameters to be updated.
   * 
   * NOTE: All parameters must be supplied.
   */
  params?: ParamsAmino;
}
export interface MsgUpdateParamsAminoMsg {
  type: "/side.tss.MsgUpdateParams";
  value: MsgUpdateParamsAmino;
}
/**
 * MsgUpdateParams is the Msg/UpdateParams request type.
 * 
 * Since: cosmos-sdk 0.47
 */
export interface MsgUpdateParamsSDKType {
  authority: string;
  params: ParamsSDKType;
}
/**
 * MsgUpdateParamsResponse defines the Msg/UpdateParams response type.
 * 
 * Since: cosmos-sdk 0.47
 */
export interface MsgUpdateParamsResponse {}
export interface MsgUpdateParamsResponseProtoMsg {
  typeUrl: "/side.tss.MsgUpdateParamsResponse";
  value: Uint8Array;
}
/**
 * MsgUpdateParamsResponse defines the Msg/UpdateParams response type.
 * 
 * Since: cosmos-sdk 0.47
 */
export interface MsgUpdateParamsResponseAmino {}
export interface MsgUpdateParamsResponseAminoMsg {
  type: "/side.tss.MsgUpdateParamsResponse";
  value: MsgUpdateParamsResponseAmino;
}
/**
 * MsgUpdateParamsResponse defines the Msg/UpdateParams response type.
 * 
 * Since: cosmos-sdk 0.47
 */
export interface MsgUpdateParamsResponseSDKType {}
function createBaseMsgCompleteDKG(): MsgCompleteDKG {
  return {
    sender: "",
    id: BigInt(0),
    pubKeys: [],
    consensusPubkey: "",
    signature: ""
  };
}
export const MsgCompleteDKG = {
  typeUrl: "/side.tss.MsgCompleteDKG",
  encode(message: MsgCompleteDKG, writer: BinaryWriter = BinaryWriter.create()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== BigInt(0)) {
      writer.uint32(16).uint64(message.id);
    }
    for (const v of message.pubKeys) {
      writer.uint32(26).string(v!);
    }
    if (message.consensusPubkey !== "") {
      writer.uint32(34).string(message.consensusPubkey);
    }
    if (message.signature !== "") {
      writer.uint32(42).string(message.signature);
    }
    return writer;
  },
  decode(input: BinaryReader | Uint8Array, length?: number): MsgCompleteDKG {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCompleteDKG();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.id = reader.uint64();
          break;
        case 3:
          message.pubKeys.push(reader.string());
          break;
        case 4:
          message.consensusPubkey = reader.string();
          break;
        case 5:
          message.signature = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object: Partial<MsgCompleteDKG>): MsgCompleteDKG {
    const message = createBaseMsgCompleteDKG();
    message.sender = object.sender ?? "";
    message.id = object.id !== undefined && object.id !== null ? BigInt(object.id.toString()) : BigInt(0);
    message.pubKeys = object.pubKeys?.map(e => e) || [];
    message.consensusPubkey = object.consensusPubkey ?? "";
    message.signature = object.signature ?? "";
    return message;
  },
  fromAmino(object: MsgCompleteDKGAmino): MsgCompleteDKG {
    const message = createBaseMsgCompleteDKG();
    if (object.sender !== undefined && object.sender !== null) {
      message.sender = object.sender;
    }
    if (object.id !== undefined && object.id !== null) {
      message.id = BigInt(object.id);
    }
    message.pubKeys = object.pub_keys?.map(e => e) || [];
    if (object.consensus_pubkey !== undefined && object.consensus_pubkey !== null) {
      message.consensusPubkey = object.consensus_pubkey;
    }
    if (object.signature !== undefined && object.signature !== null) {
      message.signature = object.signature;
    }
    return message;
  },
  toAmino(message: MsgCompleteDKG): MsgCompleteDKGAmino {
    const obj: any = {};
    obj.sender = message.sender === "" ? undefined : message.sender;
    obj.id = message.id !== BigInt(0) ? message.id.toString() : undefined;
    if (message.pubKeys) {
      obj.pub_keys = message.pubKeys.map(e => e);
    } else {
      obj.pub_keys = message.pubKeys;
    }
    obj.consensus_pubkey = message.consensusPubkey === "" ? undefined : message.consensusPubkey;
    obj.signature = message.signature === "" ? undefined : message.signature;
    return obj;
  },
  fromAminoMsg(object: MsgCompleteDKGAminoMsg): MsgCompleteDKG {
    return MsgCompleteDKG.fromAmino(object.value);
  },
  fromProtoMsg(message: MsgCompleteDKGProtoMsg): MsgCompleteDKG {
    return MsgCompleteDKG.decode(message.value);
  },
  toProto(message: MsgCompleteDKG): Uint8Array {
    return MsgCompleteDKG.encode(message).finish();
  },
  toProtoMsg(message: MsgCompleteDKG): MsgCompleteDKGProtoMsg {
    return {
      typeUrl: "/side.tss.MsgCompleteDKG",
      value: MsgCompleteDKG.encode(message).finish()
    };
  }
};
function createBaseMsgCompleteDKGResponse(): MsgCompleteDKGResponse {
  return {};
}
export const MsgCompleteDKGResponse = {
  typeUrl: "/side.tss.MsgCompleteDKGResponse",
  encode(_: MsgCompleteDKGResponse, writer: BinaryWriter = BinaryWriter.create()): BinaryWriter {
    return writer;
  },
  decode(input: BinaryReader | Uint8Array, length?: number): MsgCompleteDKGResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCompleteDKGResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(_: Partial<MsgCompleteDKGResponse>): MsgCompleteDKGResponse {
    const message = createBaseMsgCompleteDKGResponse();
    return message;
  },
  fromAmino(_: MsgCompleteDKGResponseAmino): MsgCompleteDKGResponse {
    const message = createBaseMsgCompleteDKGResponse();
    return message;
  },
  toAmino(_: MsgCompleteDKGResponse): MsgCompleteDKGResponseAmino {
    const obj: any = {};
    return obj;
  },
  fromAminoMsg(object: MsgCompleteDKGResponseAminoMsg): MsgCompleteDKGResponse {
    return MsgCompleteDKGResponse.fromAmino(object.value);
  },
  fromProtoMsg(message: MsgCompleteDKGResponseProtoMsg): MsgCompleteDKGResponse {
    return MsgCompleteDKGResponse.decode(message.value);
  },
  toProto(message: MsgCompleteDKGResponse): Uint8Array {
    return MsgCompleteDKGResponse.encode(message).finish();
  },
  toProtoMsg(message: MsgCompleteDKGResponse): MsgCompleteDKGResponseProtoMsg {
    return {
      typeUrl: "/side.tss.MsgCompleteDKGResponse",
      value: MsgCompleteDKGResponse.encode(message).finish()
    };
  }
};
function createBaseMsgSubmitSignatures(): MsgSubmitSignatures {
  return {
    sender: "",
    id: BigInt(0),
    signatures: []
  };
}
export const MsgSubmitSignatures = {
  typeUrl: "/side.tss.MsgSubmitSignatures",
  encode(message: MsgSubmitSignatures, writer: BinaryWriter = BinaryWriter.create()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== BigInt(0)) {
      writer.uint32(16).uint64(message.id);
    }
    for (const v of message.signatures) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },
  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitSignatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitSignatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.id = reader.uint64();
          break;
        case 3:
          message.signatures.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object: Partial<MsgSubmitSignatures>): MsgSubmitSignatures {
    const message = createBaseMsgSubmitSignatures();
    message.sender = object.sender ?? "";
    message.id = object.id !== undefined && object.id !== null ? BigInt(object.id.toString()) : BigInt(0);
    message.signatures = object.signatures?.map(e => e) || [];
    return message;
  },
  fromAmino(object: MsgSubmitSignaturesAmino): MsgSubmitSignatures {
    const message = createBaseMsgSubmitSignatures();
    if (object.sender !== undefined && object.sender !== null) {
      message.sender = object.sender;
    }
    if (object.id !== undefined && object.id !== null) {
      message.id = BigInt(object.id);
    }
    message.signatures = object.signatures?.map(e => e) || [];
    return message;
  },
  toAmino(message: MsgSubmitSignatures): MsgSubmitSignaturesAmino {
    const obj: any = {};
    obj.sender = message.sender === "" ? undefined : message.sender;
    obj.id = message.id !== BigInt(0) ? message.id.toString() : undefined;
    if (message.signatures) {
      obj.signatures = message.signatures.map(e => e);
    } else {
      obj.signatures = message.signatures;
    }
    return obj;
  },
  fromAminoMsg(object: MsgSubmitSignaturesAminoMsg): MsgSubmitSignatures {
    return MsgSubmitSignatures.fromAmino(object.value);
  },
  fromProtoMsg(message: MsgSubmitSignaturesProtoMsg): MsgSubmitSignatures {
    return MsgSubmitSignatures.decode(message.value);
  },
  toProto(message: MsgSubmitSignatures): Uint8Array {
    return MsgSubmitSignatures.encode(message).finish();
  },
  toProtoMsg(message: MsgSubmitSignatures): MsgSubmitSignaturesProtoMsg {
    return {
      typeUrl: "/side.tss.MsgSubmitSignatures",
      value: MsgSubmitSignatures.encode(message).finish()
    };
  }
};
function createBaseMsgSubmitSignaturesResponse(): MsgSubmitSignaturesResponse {
  return {};
}
export const MsgSubmitSignaturesResponse = {
  typeUrl: "/side.tss.MsgSubmitSignaturesResponse",
  encode(_: MsgSubmitSignaturesResponse, writer: BinaryWriter = BinaryWriter.create()): BinaryWriter {
    return writer;
  },
  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitSignaturesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitSignaturesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(_: Partial<MsgSubmitSignaturesResponse>): MsgSubmitSignaturesResponse {
    const message = createBaseMsgSubmitSignaturesResponse();
    return message;
  },
  fromAmino(_: MsgSubmitSignaturesResponseAmino): MsgSubmitSignaturesResponse {
    const message = createBaseMsgSubmitSignaturesResponse();
    return message;
  },
  toAmino(_: MsgSubmitSignaturesResponse): MsgSubmitSignaturesResponseAmino {
    const obj: any = {};
    return obj;
  },
  fromAminoMsg(object: MsgSubmitSignaturesResponseAminoMsg): MsgSubmitSignaturesResponse {
    return MsgSubmitSignaturesResponse.fromAmino(object.value);
  },
  fromProtoMsg(message: MsgSubmitSignaturesResponseProtoMsg): MsgSubmitSignaturesResponse {
    return MsgSubmitSignaturesResponse.decode(message.value);
  },
  toProto(message: MsgSubmitSignaturesResponse): Uint8Array {
    return MsgSubmitSignaturesResponse.encode(message).finish();
  },
  toProtoMsg(message: MsgSubmitSignaturesResponse): MsgSubmitSignaturesResponseProtoMsg {
    return {
      typeUrl: "/side.tss.MsgSubmitSignaturesResponse",
      value: MsgSubmitSignaturesResponse.encode(message).finish()
    };
  }
};
function createBaseMsgRefresh(): MsgRefresh {
  return {
    authority: "",
    dkgIds: [],
    removedParticipants: [],
    thresholds: [],
    timeoutDuration: Duration.fromPartial({})
  };
}
export const MsgRefresh = {
  typeUrl: "/side.tss.MsgRefresh",
  encode(message: MsgRefresh, writer: BinaryWriter = BinaryWriter.create()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    writer.uint32(18).fork();
    for (const v of message.dkgIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    for (const v of message.removedParticipants) {
      writer.uint32(26).string(v!);
    }
    writer.uint32(34).fork();
    for (const v of message.thresholds) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.timeoutDuration !== undefined) {
      Duration.encode(message.timeoutDuration, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input: BinaryReader | Uint8Array, length?: number): MsgRefresh {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRefresh();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authority = reader.string();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dkgIds.push(reader.uint64());
            }
          } else {
            message.dkgIds.push(reader.uint64());
          }
          break;
        case 3:
          message.removedParticipants.push(reader.string());
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.thresholds.push(reader.uint32());
            }
          } else {
            message.thresholds.push(reader.uint32());
          }
          break;
        case 5:
          message.timeoutDuration = Duration.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object: Partial<MsgRefresh>): MsgRefresh {
    const message = createBaseMsgRefresh();
    message.authority = object.authority ?? "";
    message.dkgIds = object.dkgIds?.map(e => BigInt(e.toString())) || [];
    message.removedParticipants = object.removedParticipants?.map(e => e) || [];
    message.thresholds = object.thresholds?.map(e => e) || [];
    message.timeoutDuration = object.timeoutDuration !== undefined && object.timeoutDuration !== null ? Duration.fromPartial(object.timeoutDuration) : undefined;
    return message;
  },
  fromAmino(object: MsgRefreshAmino): MsgRefresh {
    const message = createBaseMsgRefresh();
    if (object.authority !== undefined && object.authority !== null) {
      message.authority = object.authority;
    }
    message.dkgIds = object.dkg_ids?.map(e => BigInt(e)) || [];
    message.removedParticipants = object.removed_participants?.map(e => e) || [];
    message.thresholds = object.thresholds?.map(e => e) || [];
    if (object.timeout_duration !== undefined && object.timeout_duration !== null) {
      message.timeoutDuration = Duration.fromAmino(object.timeout_duration);
    }
    return message;
  },
  toAmino(message: MsgRefresh): MsgRefreshAmino {
    const obj: any = {};
    obj.authority = message.authority === "" ? undefined : message.authority;
    if (message.dkgIds) {
      obj.dkg_ids = message.dkgIds.map(e => e.toString());
    } else {
      obj.dkg_ids = message.dkgIds;
    }
    if (message.removedParticipants) {
      obj.removed_participants = message.removedParticipants.map(e => e);
    } else {
      obj.removed_participants = message.removedParticipants;
    }
    if (message.thresholds) {
      obj.thresholds = message.thresholds.map(e => e);
    } else {
      obj.thresholds = message.thresholds;
    }
    obj.timeout_duration = message.timeoutDuration ? Duration.toAmino(message.timeoutDuration) : undefined;
    return obj;
  },
  fromAminoMsg(object: MsgRefreshAminoMsg): MsgRefresh {
    return MsgRefresh.fromAmino(object.value);
  },
  fromProtoMsg(message: MsgRefreshProtoMsg): MsgRefresh {
    return MsgRefresh.decode(message.value);
  },
  toProto(message: MsgRefresh): Uint8Array {
    return MsgRefresh.encode(message).finish();
  },
  toProtoMsg(message: MsgRefresh): MsgRefreshProtoMsg {
    return {
      typeUrl: "/side.tss.MsgRefresh",
      value: MsgRefresh.encode(message).finish()
    };
  }
};
function createBaseMsgRefreshResponse(): MsgRefreshResponse {
  return {};
}
export const MsgRefreshResponse = {
  typeUrl: "/side.tss.MsgRefreshResponse",
  encode(_: MsgRefreshResponse, writer: BinaryWriter = BinaryWriter.create()): BinaryWriter {
    return writer;
  },
  decode(input: BinaryReader | Uint8Array, length?: number): MsgRefreshResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRefreshResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(_: Partial<MsgRefreshResponse>): MsgRefreshResponse {
    const message = createBaseMsgRefreshResponse();
    return message;
  },
  fromAmino(_: MsgRefreshResponseAmino): MsgRefreshResponse {
    const message = createBaseMsgRefreshResponse();
    return message;
  },
  toAmino(_: MsgRefreshResponse): MsgRefreshResponseAmino {
    const obj: any = {};
    return obj;
  },
  fromAminoMsg(object: MsgRefreshResponseAminoMsg): MsgRefreshResponse {
    return MsgRefreshResponse.fromAmino(object.value);
  },
  fromProtoMsg(message: MsgRefreshResponseProtoMsg): MsgRefreshResponse {
    return MsgRefreshResponse.decode(message.value);
  },
  toProto(message: MsgRefreshResponse): Uint8Array {
    return MsgRefreshResponse.encode(message).finish();
  },
  toProtoMsg(message: MsgRefreshResponse): MsgRefreshResponseProtoMsg {
    return {
      typeUrl: "/side.tss.MsgRefreshResponse",
      value: MsgRefreshResponse.encode(message).finish()
    };
  }
};
function createBaseMsgCompleteRefreshing(): MsgCompleteRefreshing {
  return {
    sender: "",
    id: BigInt(0),
    consensusPubkey: "",
    signature: ""
  };
}
export const MsgCompleteRefreshing = {
  typeUrl: "/side.tss.MsgCompleteRefreshing",
  encode(message: MsgCompleteRefreshing, writer: BinaryWriter = BinaryWriter.create()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== BigInt(0)) {
      writer.uint32(16).uint64(message.id);
    }
    if (message.consensusPubkey !== "") {
      writer.uint32(26).string(message.consensusPubkey);
    }
    if (message.signature !== "") {
      writer.uint32(34).string(message.signature);
    }
    return writer;
  },
  decode(input: BinaryReader | Uint8Array, length?: number): MsgCompleteRefreshing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCompleteRefreshing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.id = reader.uint64();
          break;
        case 3:
          message.consensusPubkey = reader.string();
          break;
        case 4:
          message.signature = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object: Partial<MsgCompleteRefreshing>): MsgCompleteRefreshing {
    const message = createBaseMsgCompleteRefreshing();
    message.sender = object.sender ?? "";
    message.id = object.id !== undefined && object.id !== null ? BigInt(object.id.toString()) : BigInt(0);
    message.consensusPubkey = object.consensusPubkey ?? "";
    message.signature = object.signature ?? "";
    return message;
  },
  fromAmino(object: MsgCompleteRefreshingAmino): MsgCompleteRefreshing {
    const message = createBaseMsgCompleteRefreshing();
    if (object.sender !== undefined && object.sender !== null) {
      message.sender = object.sender;
    }
    if (object.id !== undefined && object.id !== null) {
      message.id = BigInt(object.id);
    }
    if (object.consensus_pubkey !== undefined && object.consensus_pubkey !== null) {
      message.consensusPubkey = object.consensus_pubkey;
    }
    if (object.signature !== undefined && object.signature !== null) {
      message.signature = object.signature;
    }
    return message;
  },
  toAmino(message: MsgCompleteRefreshing): MsgCompleteRefreshingAmino {
    const obj: any = {};
    obj.sender = message.sender === "" ? undefined : message.sender;
    obj.id = message.id !== BigInt(0) ? message.id.toString() : undefined;
    obj.consensus_pubkey = message.consensusPubkey === "" ? undefined : message.consensusPubkey;
    obj.signature = message.signature === "" ? undefined : message.signature;
    return obj;
  },
  fromAminoMsg(object: MsgCompleteRefreshingAminoMsg): MsgCompleteRefreshing {
    return MsgCompleteRefreshing.fromAmino(object.value);
  },
  fromProtoMsg(message: MsgCompleteRefreshingProtoMsg): MsgCompleteRefreshing {
    return MsgCompleteRefreshing.decode(message.value);
  },
  toProto(message: MsgCompleteRefreshing): Uint8Array {
    return MsgCompleteRefreshing.encode(message).finish();
  },
  toProtoMsg(message: MsgCompleteRefreshing): MsgCompleteRefreshingProtoMsg {
    return {
      typeUrl: "/side.tss.MsgCompleteRefreshing",
      value: MsgCompleteRefreshing.encode(message).finish()
    };
  }
};
function createBaseMsgCompleteRefreshingResponse(): MsgCompleteRefreshingResponse {
  return {};
}
export const MsgCompleteRefreshingResponse = {
  typeUrl: "/side.tss.MsgCompleteRefreshingResponse",
  encode(_: MsgCompleteRefreshingResponse, writer: BinaryWriter = BinaryWriter.create()): BinaryWriter {
    return writer;
  },
  decode(input: BinaryReader | Uint8Array, length?: number): MsgCompleteRefreshingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCompleteRefreshingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(_: Partial<MsgCompleteRefreshingResponse>): MsgCompleteRefreshingResponse {
    const message = createBaseMsgCompleteRefreshingResponse();
    return message;
  },
  fromAmino(_: MsgCompleteRefreshingResponseAmino): MsgCompleteRefreshingResponse {
    const message = createBaseMsgCompleteRefreshingResponse();
    return message;
  },
  toAmino(_: MsgCompleteRefreshingResponse): MsgCompleteRefreshingResponseAmino {
    const obj: any = {};
    return obj;
  },
  fromAminoMsg(object: MsgCompleteRefreshingResponseAminoMsg): MsgCompleteRefreshingResponse {
    return MsgCompleteRefreshingResponse.fromAmino(object.value);
  },
  fromProtoMsg(message: MsgCompleteRefreshingResponseProtoMsg): MsgCompleteRefreshingResponse {
    return MsgCompleteRefreshingResponse.decode(message.value);
  },
  toProto(message: MsgCompleteRefreshingResponse): Uint8Array {
    return MsgCompleteRefreshingResponse.encode(message).finish();
  },
  toProtoMsg(message: MsgCompleteRefreshingResponse): MsgCompleteRefreshingResponseProtoMsg {
    return {
      typeUrl: "/side.tss.MsgCompleteRefreshingResponse",
      value: MsgCompleteRefreshingResponse.encode(message).finish()
    };
  }
};
function createBaseMsgUpdateParams(): MsgUpdateParams {
  return {
    authority: "",
    params: Params.fromPartial({})
  };
}
export const MsgUpdateParams = {
  typeUrl: "/side.tss.MsgUpdateParams",
  encode(message: MsgUpdateParams, writer: BinaryWriter = BinaryWriter.create()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authority = reader.string();
          break;
        case 2:
          message.params = Params.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object: Partial<MsgUpdateParams>): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = object.params !== undefined && object.params !== null ? Params.fromPartial(object.params) : undefined;
    return message;
  },
  fromAmino(object: MsgUpdateParamsAmino): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    if (object.authority !== undefined && object.authority !== null) {
      message.authority = object.authority;
    }
    if (object.params !== undefined && object.params !== null) {
      message.params = Params.fromAmino(object.params);
    }
    return message;
  },
  toAmino(message: MsgUpdateParams): MsgUpdateParamsAmino {
    const obj: any = {};
    obj.authority = message.authority === "" ? undefined : message.authority;
    obj.params = message.params ? Params.toAmino(message.params) : undefined;
    return obj;
  },
  fromAminoMsg(object: MsgUpdateParamsAminoMsg): MsgUpdateParams {
    return MsgUpdateParams.fromAmino(object.value);
  },
  fromProtoMsg(message: MsgUpdateParamsProtoMsg): MsgUpdateParams {
    return MsgUpdateParams.decode(message.value);
  },
  toProto(message: MsgUpdateParams): Uint8Array {
    return MsgUpdateParams.encode(message).finish();
  },
  toProtoMsg(message: MsgUpdateParams): MsgUpdateParamsProtoMsg {
    return {
      typeUrl: "/side.tss.MsgUpdateParams",
      value: MsgUpdateParams.encode(message).finish()
    };
  }
};
function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}
export const MsgUpdateParamsResponse = {
  typeUrl: "/side.tss.MsgUpdateParamsResponse",
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = BinaryWriter.create()): BinaryWriter {
    return writer;
  },
  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(_: Partial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
  fromAmino(_: MsgUpdateParamsResponseAmino): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
  toAmino(_: MsgUpdateParamsResponse): MsgUpdateParamsResponseAmino {
    const obj: any = {};
    return obj;
  },
  fromAminoMsg(object: MsgUpdateParamsResponseAminoMsg): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromAmino(object.value);
  },
  fromProtoMsg(message: MsgUpdateParamsResponseProtoMsg): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.decode(message.value);
  },
  toProto(message: MsgUpdateParamsResponse): Uint8Array {
    return MsgUpdateParamsResponse.encode(message).finish();
  },
  toProtoMsg(message: MsgUpdateParamsResponse): MsgUpdateParamsResponseProtoMsg {
    return {
      typeUrl: "/side.tss.MsgUpdateParamsResponse",
      value: MsgUpdateParamsResponse.encode(message).finish()
    };
  }
};